--DEBUGWIP
--IHTearDown.lua
--Dumps data from mgsv globals
--Builds mock modules.
local this={}

--TODO rename knownmodulenames.lua
--TODO DEBUGNOW move knownmodulenames to modules.
--TODO: knownmodulenames,infteardown,autodoc are kinda seperate from standard modules?

this.dumpDir=[[D:\Projects\MGS\dump\]]

--DEBUGNOW trying shiz out
function this.PostAllModulesLoad()
  InfCore.Log("IHTearDown.PostAllModulesLoad")
  
  if true then return end
  
  local globalsByType=this.GetGlobalsByType()
  --InfCore.PrintInspect(globalsByType)

  --tex doesnt produce anything
  --  local arrayData={}

  --  for k,v in pairs(globalsByType.table)do
  --    local arrayCount=v[arrayCountIdent]
  --    if arrayCount~=nil and arrayCount~=0 then
  --      arrayData[k]={}
  --      for i=0,arrayCount-1 do
  --        arrayData[k][i]=v[i]
  --      end
  --    end
  --  end
  --  local outDir=[[D:\Projects\MGS\dump\arraydata\]]
  --  this.DumpToFiles(outDir,arrayData)

  --local keysByType=this.GetModuleKeysByType(globalsByType.table)

  --local plainTextModules=this.GetPlainTextModules(globalsByType.table)
  --InfCore.PrintInspect(plainTextModules,"plainTextModules")--DEBUG

---

  local metaTableFuncTypes={
    "__call",
    "__index",
    "__newindex",
  }

  local modulesByMetaType={}
  for i,funcName in ipairs(metaTableFuncTypes)do
    modulesByMetaType[funcName]={}
  end

  for moduleName,module in pairs(globalsByType.table)do
    for i,funcName in ipairs(metaTableFuncTypes)do
      if module[funcName] then
        modulesByMetaType[funcName][moduleName]=true
      end
    end
  end

  InfCore.PrintInspect(modulesByMetaType)
end

function this.DumpModules()
  local globalsByType=this.GetGlobalsByType()
  --InfCore.PrintInspect(globalsByType)

  --tex NOTE internal C tables/modules exposed from MGS_TPP.exe are kinda funky,
  --a few are normal, plain text keys as you'd expect.
  --most are doing something with indexing metatables via some custom class binding i guess
  --the most common is fox table (don't know actual name)
  --these will either act as arrays with [-285212672] acting as item count
  --or [key name] being index into [some number]
  --or [key name] being index into [-285212671][some number]
  --some number doesnt seem to be strcode32
  --some times its [-285212671][some string] which is a normal name

  --many have a _classname string, these have plain text keys/dont have the somenumber indirection

  local arrayCountIdent=-285212672
  local arrayIdent=-285212671


  local mockModules=this.BuildMockModules(globalsByType.table)
  --InfCore.PrintInspect(mockModules,"mockModules")--DEBUG

--DEBUGNOW
  --tex NOTE: takes a fair while to run. Run it once, then use the resulting combined table .lua (after copying it to MGS_TPP\mod\modules and lauding it) --DEBUGNOW
  --open ih_log.txt in an editor that live refreshes to see progress
  --local moduleReferences=this.GetModuleReferences(globalsByType.table)
  --InfCore.PrintInspect(moduleReferences,"moduleReferences")--DEBUG

  local moduleReferences=IHGenModuleReferences--ASSUMPTION output of above has been loaded as a module

  local mockModulesFromRefs=this.BuildMockModulesFromReferences(globalsByType.table,moduleReferences)

  InfCore.Log("combine mockModulesFromRefs to mockModules")
  for moduleName,module in pairs(mockModulesFromRefs) do
    for k,v in pairs(module)do
      if not mockModules[moduleName] then
        InfCore.Log(moduleName.." could not find module in mockmodules")
      elseif not mockModules[moduleName][k] then
        mockModules[moduleName][k]=v
      end
    end
  end

  local varsTable=this.DumpVars()

  --tex write dumps
  local header=[[
--ModulesDump.lua
--GENERATED by IHTearDown
--Straight Inspect dump of mgstpp global tables
]]
  local outDir=this.dumpDir..[[modulesDump\]]
  this.DumpToFiles(outDir,globalsByType.table)
  this.WriteTable(this.dumpDir.."ModulesDump.lua",header,globalsByType.table)
  
  local header=[[
--IHGenModuleReferences.lua
--GENERATED by IHTearDown.DumpModules > GetModuleReferences
--is scrape of references to modules in .lua files
]]
  local outDir=this.dumpDir..[[moduleReference\]]
  this.DumpToFiles(outDir,moduleReferences)
  this.WriteTable(this.dumpDir.."IHGenModuleReferences.lua",header,moduleReferences)

  local header=[[
--MockModules.lua
--GENERATED by IHTearDown from running mgs combined with scrapes of .lua files for further module references (due to internal mgs_tpp modules indexing crud, see NOTE in DumpModules)
]]  
  local outDir=this.dumpDir..[[mockModules\]]
  this.DumpToFiles(outDir,mockModules)
  this.WriteTable(this.dumpDir.."MockModules.lua",header,mockModules)

  local header=[[
--vars.lua
--GENERATED by IHTearDown 
--dump of vars
]]  
  this.WriteTable(this.dumpDir.."vars.lua",header,varsTable)
end

--tex breaks down global variables by type
--IN/SIDE: IHGenKnownModuleNames, _G
--OUT: globalsByType
function this.GetGlobalsByType()
  local ModuleNames=IHGenKnownModuleNames

  --tex names of tables in KnownModuleNames to skip
  local skipModuleTableNames={
    "ihInternal",
    "ihExternal",
    "tppInternal",
    "luaInternal",
  }

  local skipModuleNames={
    _G=true,
    package=true,
    this=true,
  }

  local globalsByType={
    ["table"]={},
    ["function"]={},
    ["string"]={},
    other={},
  }
  local globalFunctions={}
  local globalTables={}
  local globalOther={}
  for k,v in pairs(_G)do
    local addEntry=true
    for i,moduleNameTable in ipairs(skipModuleTableNames)do
      if ModuleNames[moduleNameTable] and ModuleNames[moduleNameTable][k] then
        addEntry=false
        break
      end
    end

    if skipModuleNames[k] then
      addEntry=false
    end

    --tex theres some strange edge cases where theres a provided lua, but also an exe internal module of that name
    if ModuleNames.exeInternal[k] then
      addEntry=true
    end

    if addEntry then
      local types=globalsByType[type(v)]
      types=types or globalsByType.other
      types[k]=v
    end
  end
  return globalsByType
end

--tex breaks down modules keys by type
function this.GetModuleKeysByType(modules)
  InfCore.Log("GetModuleKeysByType")
  local breakDown={}
  for moduleName,module in pairs(modules)do
    local tableInfo={
      stringKeys={},
      numberKeys={},
    }
    local function GetTableKeys(checkTable,tableInfo)
      for key,value in pairs(checkTable)do
        if type(key)=="string" then
          table.insert(tableInfo.stringKeys,key)
        elseif type(key)=="number" then
          table.insert(tableInfo.numberKeys,key)
          if type(value)=="table" then
            GetTableKeys(value)
          end
        end
      end
    end

    GetTableKeys(module,tableInfo)

    if #tableInfo.numberKeys>0 then
      breakDown[moduleName]=tableInfo
    end
  end
end

--tex scrapes module references from lua files
--DEBUGNOW TODO figure out if it's a function or a variable "(" follows reference name
function this.GetModuleReferences(modules)
  InfCore.Log("GetModuleReferences")

  --tex get paths of lua files ASSUMPTION: all lua files in one folder/no subfolders
  local luaFolder=[[J:\GameData\MGS\filetypecrushed\lua\]]--DEBUGNOW
  local outName="luaFileList.txt"
  
  local startTime=os.clock()

  local cmd=[[dir /s /b "]]..luaFolder..[[*.lua" > "]]..luaFolder..outName..[["]]
  InfCore.Log(cmd)
  os.execute(cmd)

  local luaFilePaths=InfCore.GetLines(luaFolder..outName)
  --InfCore.PrintInspect(luaFilePaths,"luaFilePaths")--DEBUG
  
  local numFiles=#luaFilePaths

  local refs={}
  for i,filePath in ipairs(luaFilePaths)do
    InfCore.Log("["..i.."//"..numFiles.."] "..filePath)--DEBUG
    local lines=InfCore.GetLines(filePath)
    for i,fileLine in ipairs(lines)do
      for moduleName,moduleInfo in pairs(modules)do
        local fileLine=fileLine

        --tex break up lines
        local brokenLines={}
        local delim = {
          ",", " ", "\n", "%]", "%)", "}", "\t",
          "%+","-",">","<","=","/","%*","~","%%",
          "'","\"","{","%(","%[",
        }
        local pattern = "[^"..table.concat(delim).."]+"
        for w in fileLine:gmatch(pattern) do
          --InfCore.Log(w)
          table.insert(brokenLines,w)
        end

        --InfCore.Log("looking for "..moduleName)--DEBUGNOW
        for i,line in ipairs(brokenLines)do
          local findIndex,findEndIndex=string.find(line,moduleName)
          while(findIndex~=nil)do
            local findEndIndex=findIndex+string.len(moduleName)
            line=string.sub(line,findEndIndex)
            local nextChar=string.sub(line,1,1)
            --InfCore.Log("find: "..moduleName.. " line:"..line)--DEBUGNOW
            --InfCore.Log("find: "..moduleName.. " nextChar:"..nextChar)--DEBUGNOW
            if nextChar=="." or nextChar==":" then
              --DEBUGNOW TODO: handle + - < > == number (can + be concat string too?)

              --              local keyType
              --              if line:find("%(") then
              --                keyType="function"
              --                key=key:sub(1,key:len()-1)
              --              elseif line:find("%[") then
              --                keyType="table"
              --                key=key:sub(1,key:len()-1)
              --             elseif line:find("%:") then--DEBUGNOW
              --                --keyType=""--tex most likely a comment
              --                key=key:sub(1,key:len()-1)
              --              elseif line:find("=") then
              --                if line:find("={") then
              --                  keyType="table"
              --                elseif line:find("='") then
              --                  keyType="string"
              --                elseif line:find("=\"") then
              --                  keyType="string"
              --                end
              --                --tex =something is unknown, could be any type being assigned to it
              --                local endIndex=line:find("=")
              --                key=key:sub(1,endIndex-2)
              --              end

              local key=string.sub(line,2)--tex strip leading .

              local keyEndIndex=string.find(key,"[%.:]")
              if keyEndIndex then
                key=string.sub(key,1,keyEndIndex-1)
              end

              local nextChar=string.sub(key,1,1)
              if findIndex==1 then--DEBUGNOW
                if key~="" and type(nextChar)~="number"then
                  refs[moduleName]=refs[moduleName]or{}
                  refs[moduleName][key]=true
              end
              end
            end

            findIndex=string.find(line,moduleName)
            --InfCore.Log(findIndex)--DEBUGNOW
          end
        end
      end
    end
  end
  
  InfCore.Log(string.format("GetModuleReferences completed in: %.2f", os.clock() - startTime))

  return refs
end

function this.BuildMockModules(modules)
  local mockModules={}

  local ignoreModules={
    vars=true,
    cvars=true,
    gvars=true,
    svars=true,
    mvars=true,
  }

  local ignoreKeys={
    --    __call=true,
    --    __newindex=true,
    --    __index=true,
    }

  for moduleName,module in pairs(modules)do
    if not ignoreModules[moduleName] then
      mockModules[moduleName]={}
      for k,v in pairs(module)do
        --NOTE only string keys to skip userdata/indexified modules keys, see NOTE in DumpModules
        if type(k)=="string" then
          if not ignoreKeys[k] then
            if type(v)=="function" then
              mockModules[moduleName][k]="<function>"
            elseif type(v)=="table" then
              mockModules[moduleName][k]="<table>"
            elseif type(v)=="userdata" then
              mockModules[moduleName][k]="<userdata: "..tostring(v)..">"
            else
              mockModules[moduleName][k]=v
            end
          end
        end
      end
    end
  end
  return mockModules
end


function this.BuildMockModulesFromReferences(modules,moduleReferences)
  local mockModules={}

  local ignoreModules={
    vars=true,
    cvars=true,
    gvars=true,
    svars=true,
    mvars=true,
  }

  local ignoreKeys={
    --    __call=true,
    --    __index=true,
    --    __newindex=true,
    }

  for moduleName,referenceModule in pairs(moduleReferences)do
    if not ignoreModules[moduleName] then
      mockModules[moduleName]={}
      if not modules[moduleName] then
        InfCore.Log("Could not find module from moduleRefereces in modules:"..moduleName)
      else
        local liveModule=modules[moduleName]
        for k,v in pairs(referenceModule)do
          local liveValue=liveModule[k]
          if liveValue==nil then
            InfCore.Log(moduleName.." could not find key "..tostring(k))
          elseif type(k)=="string" then
            if not ignoreKeys[k] then
              if type(liveValue)=="function" then
                mockModules[moduleName][k]="<function>"
              elseif type(liveValue)=="table" then
                mockModules[moduleName][k]="<table>"
              elseif type(liveValue)=="userdata" then
                mockModules[moduleName][k]="<userdata: "..tostring(liveValue)..">"
              else
                mockModules[moduleName][k]=liveValue
              end
            end
          end
        end
      end
    end
  end
  return mockModules
end

function this.GetPlainTextModules(modules)
  local plainTextModules={}

  local ignoreKeys={
    __call=true,
    __newindex=true,
    __index=true,
  }

  for moduleName,module in pairs(modules)do
    for k,v in pairs(module)do
      if type(k)=="string" then
        if not ignoreKeys[k] then
          plainTextModules[moduleName]=true
        end
      end
    end
  end

  return plainTextModules
end

function this.DumpVars()
  local vars=vars

  local rootArrayIdent=-285212671

  local arrayIdent=-285212665
  local arrayCountIdent=-285212666

  local varsTable={}

  for k,v in pairs(vars[rootArrayIdent])do
    varsTable[k]=vars[k]
  end

  local skipKeys={
    __index=true,
    __newindex=true,
  }

  for k,foxTable in pairs(vars)do
    --tex is actually a foxTable
    if type(foxTable)=="table" then
      if foxTable[arrayCountIdent] then
        --InfCore.Log("found foxTable "..k)--DEBUGNOW
        if type(k)=="string" then
          if not skipKeys[k] then
            local foxTableArray=foxTable[arrayIdent]
            if foxTableArray then
              varsTable[k]={}
              local arrayCount=foxTable[arrayCountIdent]
              --InfCore.Log("arrayCount="..arrayCount)--DEBUGNOW
              for i=0,arrayCount-1 do
                varsTable[k][i]=vars[k][i]
              end
            end
          end
        end
      end
    end
  end

  return varsTable
end

local open=io.open
local Inspect=InfInspect.Inspect

local nl=[[\n\r]]
function this.WriteString(filePath,someString)
  local file,error=open(filePath,"w")
  if not file or error then
    return
  end

  file:write(someString)
  file:close()
end

function this.WriteTable(fileName,header,t)
  if t==nil then
    return
  end
  InfCore.Log("WriteTable "..fileName)

  local all=InfInspect.Inspect(t)
  all="local this="..all.."\n\r".."return this"
  if header then
    all=header..all
  end
  
  this.WriteString(fileName,all)
end

function this.DumpToFiles(outDir,moduleTable)
  if moduleTable==nil then
    return
  end
  InfCore.Log("DumpToFiles "..outDir)

  for k,v in pairs(moduleTable) do
    local filename=outDir..k..'.txt'
    local ins=Inspect(v)
    this.WriteString(filename,k.."="..ins)
  end
end

return this
